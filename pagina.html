<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Reproductor DBZ — Pages</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{ --bg:#f6f7fb; --ink:#2d2a32; --muted:#6b6a73; --panel:#ffffff; --edge:#e9e8f2; --accent:#b59bff; }
    *{box-sizing:border-box} html,body{height:100%}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; color:var(--ink);
      background:
        radial-gradient(1000px 1000px at 10% -10%, #efeaff 0%, transparent 55%),
        radial-gradient(900px 900px at 100% 0%, #e3fff7 0%, transparent 55%),
        linear-gradient(180deg,var(--bg),#fdfcff 60%);
      display:flex; align-items:center; justify-content:center; padding:24px;
    }
    .player{ background:var(--panel); border:1px solid var(--edge); border-radius:22px; box-shadow:0 10px 30px rgba(23,15,41,.08); max-width:960px; width:100% }
    .header{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 16px;
      background:linear-gradient(135deg, color-mix(in oklch,var(--accent), white 20%), color-mix(in oklch,var(--accent), black 8%)); color:#2b223d }
    .title{ margin:0; font-size:16px; font-weight:700; letter-spacing:.3px }
    .badge{ font-size:12px; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.65); border:1px solid rgba(0,0,0,.05) }

    .stage{ position:relative; background:#000 }
    video{ width:100%; height:auto; display:block; background:#000; position:relative; z-index:1 }
    .center-play{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none }
    .center-play .btn-big{ pointer-events:auto; --size:72px; width:var(--size); height:var(--size); border-radius:999px; border:none; display:grid; place-items:center; font-size:28px; color:white; background:linear-gradient(180deg,rgba(0,0,0,.25),rgba(0,0,0,.45)); box-shadow:0 10px 30px rgba(0,0,0,.2) }

    .controls{ display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:14px 16px; padding:14px 16px 12px }
    .row{ display:flex; align-items:center; gap:8px }
    .btn{ --size:40px; width:var(--size); height:var(--size); display:grid; place-items:center; border-radius:12px; border:1px solid var(--edge); background:linear-gradient(180deg,#fff,#fafafe); box-shadow:0 6px 16px rgba(23,15,41,.08); cursor:pointer; color:var(--ink) }
    .btn[aria-pressed="true"]{ outline:2px solid color-mix(in oklch,var(--accent),white 15%) }

    .seek{ grid-column:1/-1; display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:10px }
    .time{ font-variant-numeric:tabular-nums; color:var(--muted); font-size:14px; min-width:70px; text-align:center }
    .range{ position:relative; height:22px; display:grid; align-items:center }
    .buffered,.progress{ pointer-events:none; position:absolute; left:0; height:4px; border-radius:999px }
    .buffered{ width:0%; background:#e8e7f4 } .progress{ width:0%; background:var(--accent) }
    input[type="range"].slider{-webkit-appearance:none; appearance:none; width:100%; height:4px; background:transparent; outline:none}
    input[type="range"].slider::-webkit-slider-thumb{-webkit-appearance:none; width:16px; height:16px; border-radius:50%; background:white; border:2px solid var(--accent); box-shadow:0 2px 6px rgba(0,0,0,.12); margin-top:-6px}
    .vol{width:min(180px,25vw)}
    input[type="range"].vol-slider{-webkit-appearance:none; appearance:none; width:100%; height:4px; background:#efeef8; border-radius:999px}
    input[type="range"].vol-slider::-webkit-slider-thumb{ width:14px; height:14px; border-radius:50%; background:var(--accent) }

    .select{ padding:8px 10px; border-radius:12px; border:1px solid var(--edge); background:linear-gradient(180deg,#fff,#fafafe); color:var(--ink) }
    .foot{ color:var(--muted); font-size:13px; padding:0 16px 16px }

    /* Subtítulos overlay */
    .captions{ position:absolute; left:0; right:0; bottom:6%; display:flex; flex-direction:column; gap:6px; align-items:center; padding:0 12px; z-index:5; pointer-events:auto }
    .cap-line{ max-width:min(86%, 900px); width:fit-content; color:#111; font-weight:600; letter-spacing:.2px; line-height:1.35; border-radius:14px; padding:8px 12px; box-shadow:0 6px 20px rgba(0,0,0,.16) }
    .track-ja{ background:rgba(255,255,255,.92) }
    .track-romaji{ background:rgba(255,245,232,.95) }
    .track-es{ background:rgba(236,253,245,.95) }

    .word-ja{ cursor:pointer; padding:0 2px; border-radius:6px }
    .word-ja:hover{ background:rgba(0,0,0,.06) }
    .track-romaji .word-ro{ pointer-events:none; cursor:default; padding:0 2px; border-radius:6px }

    /* highlight sincronizado */
    .hl { outline:2px solid color-mix(in oklch,var(--accent),white 15%); background:rgba(181,155,255,.12); border-radius:6px }

    /* Popover (solo JA) */
    .popover{ position:absolute; z-index:10; min-width:220px; max-width:320px; background:#fff; border:1px solid var(--edge); border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.15); padding:10px 12px; display:none }
    .popover .word{ font-weight:800 } .popover .hint{ color:var(--muted); font-size:12px }
    .popover .meaning{ margin-top:6px }

    /* Badges pequeños (romaji sugerido) */
    .ro-badge{ margin-left:8px; font-size:12px; padding:2px 6px; border-radius:999px; border:1px solid var(--edge); background:#fff }

    /* Diagnóstico oculto */
    .diag{ display:none; }
    .pill{ padding:4px 8px; border-radius:999px; border:1px solid var(--edge); background:#f7f7ff; white-space:nowrap }
    .tools{ display:flex; gap:8px; padding:0 16px 16px; flex-wrap:wrap }
    .tools .btn{ height:auto; padding:8px 12px; width:auto }

    ruby{ ruby-position:over; } rt{ font-size:.65em; color:#6b6a73 }
  </style>
</head>
<body>
  <div class="player" id="player" tabindex="0" aria-label="Reproductor de video con subtítulos y panel flotante">
    <div class="header">
      <h1 class="title">Proyecto integral — Reproductor</h1>
      <span class="badge" id="badgeDur">00:00</span>
    </div>

    <div class="stage">
      <video id="video" preload="metadata" playsinline webkit-playsinline poster="poster.jpg">
        <source id="src" src="video.mp4" type="video/mp4" />
        <!-- Pistas (mismo origen) -->
        <track id="trk-ja" label="日本語"   kind="subtitles" srclang="ja"      src="subs-ja.vtt" default />
        <track id="trk-ro" label="Rōmaji"  kind="subtitles" srclang="ja-Latn" src="subs-ro.vtt" />
        <track id="trk-es" label="Español" kind="subtitles" srclang="es"      src="subs-es.vtt" />
        Tu navegador no soporta la etiqueta <code>video</code>.
      </video>

      <div class="center-play"><button class="btn-big" id="bigPlay" title="Reproducir">▶</button></div>

      <div class="captions" id="captions">
        <div class="cap-line track-ja"     id="cap-ja" hidden></div>
        <div class="cap-line track-romaji" id="cap-romaji" hidden></div>
        <div class="cap-line track-es"     id="cap-es" hidden></div>
      </div>

      <div class="popover" id="popover">
        <div><span class="word" id="pv-word">—</span></div>
        <div class="hint" id="pv-read">Lectura: —</div>
        <div class="meaning" id="pv-meaning">Significado: —</div>
      </div>
    </div>

    <div class="controls" role="group" aria-label="Controles">
      <div class="row">
        <button class="btn" id="back10" title="Retroceder 10s">⟲</button>
        <button class="btn" id="play"   title="Reproducir/Pausar"><span id="icon-play">▶</span></button>
        <button class="btn" id="fwd10"  title="Avanzar 10s">⟳</button>
      </div>
      <div class="row seek" aria-label="Barra de progreso">
        <div class="time" id="currentTime">0:00</div>
        <div class="range">
          <div class="buffered" id="bufferedBar"></div>
          <div class="progress" id="progressBar"></div>
          <input id="seek" class="slider" type="range" min="0" max="1000" step="1" value="0" />
        </div>
        <div class="time" id="duration">0:00</div>
      </div>
      <div class="row">
        <button class="btn" id="mute" title="Silenciar/Activar">🔊</button>
        <div class="vol"><input id="volume" class="vol-slider" type="range" min="0" max="1" step="0.01" value="1" /></div>
      </div>
      <div class="row">
        <select id="speed" class="select" aria-label="Velocidad">
          <option value="0.5">0.5×</option>
          <option value="0.75">0.75×</option>
          <option value="1" selected>1×</option>
          <option value="1.25">1.25×</option>
          <option value="1.5">1.5×</option>
          <option value="1.75">1.75×</option>
          <option value="2">2×</option>
        </select>
        <!-- Independientes: podés combinar JA/RO/ES + Furigana -->
        <button class="btn" id="tog-ja"      aria-pressed="true"  title="Alternar Japonés">JA</button>
        <button class="btn" id="tog-romaji"  aria-pressed="false" title="Alternar Rōmaji">RO</button>
        <button class="btn" id="tog-es"      aria-pressed="false" title="Alternar Español">ES</button>
        <button class="btn" id="tog-fg"      aria-pressed="false" title="Furigana en JA">FG</button>
        <button class="btn" id="fs"          title="Pantalla completa">⤢</button>
      </div>
    </div>

    <div class="tools">
      <button class="btn" id="btnTest">Probar video de prueba (MDN)</button>
      <button class="btn" id="btnURL">Cargar por URL…</button>
      <span class="pill" id="statusSrc">src: video.mp4</span>
      <span class="pill" id="pillJA">JA: —</span>
      <span class="pill" id="pillRO">RO: —</span>
      <span class="pill" id="pillES">ES: —</span>
    </div>
    <div class="diag" id="diag"></div>

    <div class="foot">Atajos: Espacio · ←/→ ±5s · ↑/↓ volumen · M mute · F pantalla completa · J/A/E alternar JA/RO/ES · G furigana</div>
  </div>

<script>
(function(){
  const $ = (s)=>document.querySelector(s);
  const player=$('#player'), video=$('#video'), srcEl=$('#src');
    const roClickCSS = document.createElement('style');
  roClickCSS.textContent = '.track-romaji .word-ro{pointer-events:auto;cursor:pointer}';
  document.head.appendChild(roClickCSS);
  const bigPlay=$('#bigPlay'), playBtn=$('#play'), iconPlay=$('#icon-play');
  const back10=$('#back10'), fwd10=$('#fwd10'), seek=$('#seek'), progressBar=$('#progressBar'), bufferedBar=$('#bufferedBar');
  const cur=$('#currentTime'), dur=$('#duration'), muteBtn=$('#mute'), vol=$('#volume'), speed=$('#speed'), fs=$('#fs'), badgeDur=$('#badgeDur');
  const diag=$('#diag'), statusSrc=$('#statusSrc');
  const pillJA=$('#pillJA'), pillRO=$('#pillRO'), pillES=$('#pillES');

  function log(msg){ diag.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}<br>` + diag.innerHTML; }
  function setSrc(url){ srcEl.src=url; statusSrc.textContent='src: '+url; video.load(); }

  function formatTime(s){ if(!isFinite(s)) return '0:00'; const h=Math.floor(s/3600), m=Math.floor((s%3600)/60), sec=String(Math.floor(s%60)).padStart(2,'0'); return (h>0? h+':'+String(m).padStart(2,'0'):m)+':'+sec; }
  video.addEventListener('loadedmetadata',()=>{ dur.textContent=formatTime(video.duration); badgeDur.textContent=formatTime(video.duration); updateBuffered(); log('loadedmetadata OK'); });
  video.addEventListener('canplay',()=> log('canplay'));
  video.addEventListener('canplaythrough',()=> log('canplaythrough'));
  video.addEventListener('stalled',()=> log('stalled'));
  video.addEventListener('waiting',()=> log('waiting'));
  video.addEventListener('suspend',()=> log('suspend (descargando)'));
  video.addEventListener('error',()=>{ const code = video.error ? video.error.code : 'desconocido'; log('ERROR VIDEO code='+code+' (1=aborted,2=network,3=decode,4=src not supported)'); });

  function togglePlay(){ (video.paused||video.ended)?video.play():video.pause(); }
  ;[playBtn, video, bigPlay].forEach(el=>el.addEventListener('click', togglePlay));
  video.addEventListener('play', ()=>{ iconPlay.textContent='⏸'; bigPlay.style.display='none'; });
  video.addEventListener('pause', ()=>{ iconPlay.textContent='▶';  bigPlay.style.display='grid'; });

  back10.addEventListener('click', ()=> video.currentTime=Math.max(0, (video.currentTime||0)-10));
  fwd10 .addEventListener('click', ()=> video.currentTime=Math.min(video.duration||0, (video.currentTime||0)+10));
  function updateTime(){ cur.textContent=formatTime(video.currentTime); const pct=(video.currentTime/(video.duration||1))*100; progressBar.style.width=pct+'%'; seek.value=Math.round((video.currentTime/(video.duration||1))*1000)||0; }
  function updateBuffered(){ try{ if(video.buffered && video.buffered.length){ const end=video.buffered.end(video.buffered.length-1); bufferedBar.style.width=((end/(video.duration||1))*100)+'%'; } }catch(e){} }
  video.addEventListener('timeupdate', updateTime);
  video.addEventListener('progress', updateBuffered);
  video.addEventListener('loadeddata', updateBuffered);
  seek.addEventListener('input', ()=>{ video.currentTime=(seek.value/1000)*(video.duration||0); updateTime(); });

  function updateMuteIcon(){ const level=video.muted||video.volume===0?0:video.volume; muteBtn.textContent= level===0?'🔇':(level<.5?'🔈':'🔊'); }
  vol.addEventListener('input', ()=>{ video.volume=Number(vol.value); if(video.volume>0) video.muted=false; updateMuteIcon(); });
  muteBtn.addEventListener('click', ()=>{ video.muted=!video.muted; updateMuteIcon(); });
  video.addEventListener('volumechange', updateMuteIcon); updateMuteIcon();

  speed.addEventListener('change', ()=>{ video.playbackRate=Number(speed.value); });
  function toggleFS(){ if(document.fullscreenElement) document.exitFullscreen(); else player.requestFullscreen().catch(()=>{}); }
  fs.addEventListener('click', toggleFS);

  const capJA=$('#cap-ja'), capRO=$('#cap-romaji'), capES=$('#cap-es');
  const trkJA=$('#trk-ja'), trkRO=$('#trk-ro'), trkES=$('#trk-es');
  const togJA=$('#tog-ja'), togRO=$('#tog-romaji'), togES=$('#tog-es'), togFG=$('#tog-fg');

  const tracks={ ja:trkJA?.track || null, ro:trkRO?.track || null, es:trkES?.track || null };
  Object.values(tracks).forEach(t=>{ if(t){ try{ t.mode='hidden'; }catch(_){} } });

  function armTrack(el, name, pill){
    if(!el){ pill.textContent = `${name.toUpperCase()}: —`; return; }
    const t = el.track;
    function ok(){ pill.textContent = `${name.toUpperCase()}: ok (${t.cues?t.cues.length:0})`; renderCue(); }
    function err(){ pill.textContent = `${name.toUpperCase()}: error`; }
    if (el.readyState === 2) ok(); else { el.addEventListener('load', ok, {once:true}); el.addEventListener('error', err, {once:true}); }
  }
  armTrack(trkJA,'ja',pillJA); armTrack(trkRO,'ro',pillRO); armTrack(trkES,'es',pillES);

  const state={ showJA:true, showRO:false, showES:false, showFG:false };
  const setToggle=(btn,on)=>btn.setAttribute('aria-pressed', on);
  function syncToggles(){ setToggle(togJA,state.showJA); setToggle(togRO,state.showRO); setToggle(togES,state.showES); setToggle(togFG,state.showFG); }
  syncToggles();
  togJA.addEventListener('click', ()=>{ state.showJA=!state.showJA; syncToggles(); renderCue(); });
  togRO.addEventListener('click', ()=>{ state.showRO=!state.showRO; syncToggles(); renderCue(); });
  togES.addEventListener('click', ()=>{ state.showES=!state.showES; syncToggles(); renderCue(); });
  togFG.addEventListener('click', ()=>{ state.showFG=!state.showFG; syncToggles(); renderCue(); });

  /* ======== Diccionario (incluye partículas + uso) ======== */
  const JA_DICT={
    "孫悟飯":{yomi:"そんごはん",gloss:"Son Gohan (nombre propio)",ro:"son gohan"},
    "正しい":{yomi:"ただしい",gloss:"correcto; justo",ro:"tadashii"},
    "こと":{yomi:"こと",gloss:"cosa; hecho",ro:"koto"},
    "ために":{yomi:"ために",gloss:"para; por el bien de",ro:"tame ni"},
    "戦う":{yomi:"たたかう",gloss:"pelear; luchar",ro:"tatakau"},
    "罪":{yomi:"つみ",gloss:"pecado; culpa",ro:"tsumi"},
    "ではない":{yomi:"ではない",gloss:"no es; no ser (neg. de だ)",ro:"de wa nai"},
    "話し合い":{yomi:"はなしあい",gloss:"diálogo; discusión",ro:"hanashiai"},
    "など":{yomi:"など",gloss:"etc.; cosas como ~",ro:"nado"},
    /* 🔧 importante: macrones en el ro para matchear “Tsūyō shinai” */
    "通用しない":{yomi:"つうようしない",gloss:"no funciona; no surte efecto",ro:"tsūyō shinai"},
    "相手":{yomi:"あいて",gloss:"oponente; interlocutor",ro:"aite"},
    "もいるのだ":{yomi:"もいるのだ",gloss:"también hay/existen (explicativo)",ro:"mo iru no da"},
    "いるのだ":{yomi:"いるのだ",gloss:"(alguien) está/hay (explicativo)",ro:"iru no da"},
    "精神":{yomi:"せいしん",gloss:"espíritu; mente",ro:"seishin"},
    "光":{yomi:"ひかり",gloss:"luz",ro:"hikari"},
    "まま":{yomi:"まま",gloss:"tal cual; manteniendo el estado",ro:"mama",note:"X のまま = 'tal como X / manteniendo X'."},
    "自由に":{yomi:"じゆうに",gloss:"libremente",ro:"jiyū ni"},
    "解放してやれ":{yomi:"かいほうしてやれ",gloss:"libéralo / déjalo libre",ro:"kaihō shite yare"},
    "気持ち":{yomi:"きもち",gloss:"sentimiento",ro:"kimochi"},
    "分かる":{yomi:"わかる",gloss:"entender",ro:"wakaru"},
    "もう":{yomi:"もう",gloss:"ya; más",ro:"mō"},
    "我慢する":{yomi:"がまんする",gloss:"aguantarse / soportar",ro:"gaman suru"},
    "ことはない":{yomi:"ことはない",gloss:"no hace falta; no es necesario",ro:"koto wa nai"},
    "のが":{yomi:"のが",gloss:"(posesivo/nominalizador + が)",ro:"no ga"},
    // partículas
    "を":{yomi:"を",gloss:"partícula de objeto directo",ro:"wo",note:"Marca el objeto directo de la acción (A を V)."},
    "は":{yomi:"は",gloss:"partícula de tema / contraste",ro:"wa",note:"Presenta el tema; contrasta con が."},
    "が":{yomi:"が",gloss:"partícula de sujeto / énfasis",ro:"ga",note:"Marca sujeto nuevo o enfatizado."},
    "に":{yomi:"に",gloss:"tiempo/destino/receptor",ro:"ni",note:"Momento, destino, receptor (〜に)."},
    "で":{yomi:"で",gloss:"lugar/medio de la acción",ro:"de",note:"Dónde ocurre la acción o el medio usado."},
    "と":{yomi:"と",gloss:"'y' / con / cita",ro:"to",note:"Conjunción, compañía, o cita textual."},
    "も":{yomi:"も",gloss:"también / incluso",ro:"mo",note:"Añade o enfatiza inclusividad."},
    "の":{yomi:"の",gloss:"posesivo / nominalizador",ro:"no",note:"'de' / convierte en sintagma nominal."},
    "へ":{yomi:"へ",gloss:"dirección 'hacia'",ro:"e",note:"Dirección aproximada (hacia)."},
    "から":{yomi:"から",gloss:"desde / porque",ro:"kara",note:"Origen o causa."},
    "まで":{yomi:"まで",gloss:"hasta",ro:"made",note:"Límite final."},
    "より":{yomi:"より",gloss:"comparativo 'que'",ro:"yori",note:"Comparación: A より B."}
  };
  const DICT_KEYS=Object.keys(JA_DICT).sort((a,b)=>b.length-a.length);

  // Segmentación JA
  const segJA = (typeof Intl!=='undefined' && Intl.Segmenter)? new Intl.Segmenter('ja',{granularity:'word'}) : null;
  function sliceWithDict(line){
    const out=[]; let i=0;
    while(i<line.length){
      let m=null;
      for(const k of DICT_KEYS){ if(line.startsWith(k,i)){ m=k; break; } }
      if(m){ const e=JA_DICT[m]; out.push({text:m, dict:e, start:i, end:i+m.length}); i+=m.length; }
      else{ out.push({text:line[i], start:i, end:i+1}); i++; }
    }
    return out;
  }
  function segmentJapanese(line){
    const raw=sliceWithDict(line);
    if(!segJA){ return raw.map(p=> ({text:p.text, start:p.start, end:p.end, dict:p.dict||null})); }
    const out=[]; let buffer='', bStart=null;
    const flush=()=>{
      if(!buffer) return;
      let pos=0;
      for(const it of segJA.segment(buffer)){
        const seg=it.segment;
        const st=bStart + buffer.indexOf(seg,pos);
        const en=st+seg.length;
        pos = buffer.indexOf(seg,pos)+seg.length;
        out.push({text:seg, start:st, end:en, dict:null});
      }
      buffer=''; bStart=null;
    };
    for(const p of raw){
      if(p.dict){ flush(); out.push({text:p.text,start:p.start,end:p.end,dict:p.dict}); }
      else{ if(buffer===''){ buffer=p.text; bStart=p.start; } else buffer+=p.text; }
    }
    flush(); return out;
  }

  /* ======== Romaji helpers ======== */
  const ROMA_MAP = {
    'きゃ':'kya','きゅ':'kyu','きょ':'kyo','しゃ':'sha','しゅ':'shu','しょ':'sho','ちゃ':'cha','ちゅ':'chu','ちょ':'cho',
    'にゃ':'nya','にゅ':'nyu','にょ':'nyo','ひゃ':'hya','ひゅ':'hyu','ひょ':'hyo','みゃ':'mya','みゅ':'myu','みょ':'myo',
    'りゃ':'rya','りゅ':'ryu','りょ':'ryo','ぎゃ':'gya','ぎゅ':'gyu','ぎょ':'gyo','じゃ':'ja','じゅ':'ju','じょ':'jo',
    'びゃ':'bya','びゅ':'byu','びょ':'byo','ぴゃ':'pya','ぴゅ':'pyu','ぴょ':'pyo',
    'あ':'a','い':'i','う':'u','え':'e','お':'o','か':'ka','き':'ki','く':'ku','け':'ke','こ':'ko',
    'さ':'sa','し':'shi','す':'su','せ':'se','そ':'so','た':'ta','ち':'chi','つ':'tsu','て':'te','と':'to',
    'な':'na','に':'ni','ぬ':'nu','ね':'ne','の':'no','は':'ha','ひ':'hi','ふ':'fu','へ':'he','ほ':'ho',
    'ま':'ma','み':'mi','む':'mu','め':'me','も':'mo','や':'ya','ゆ':'yu','よ':'yo','ら':'ra','り':'ri','る':'ru','れ':'re','ろ':'ro',
    'わ':'wa','を':'wo','ん':'n',
    'が':'ga','ぎ':'gi','ぐ':'gu','げ':'ge','ご':'go','ざ':'za','じ':'ji','ず':'zu','ぜ':'ze','ぞ':'zo',
    'だ':'da','ぢ':'ji','づ':'zu','で':'de','ど':'do','ば':'ba','び':'bi','ぶ':'bu','べ':'be','ぼ':'bo','ぱ':'pa','ぴ':'pi','ぷ':'pu','ぺ':'pe','ぽ':'po',
    'ぁ':'a','ぃ':'i','ぅ':'u','ぇ':'e','ぉ':'o','ゃ':'ya','ゅ':'yu','ょ':'yo','っ':'','ー':''
  };
  function hiraToRoma(str){
    let out=''; for(let i=0;i<str.length;i++){
      const ch=str[i], next=str[i+1]||'';
      if(ch==='っ' && next){ const roma = ROMA_MAP[next] || ''; if(roma) out += roma[0]; continue; }
      const dig=str.slice(i,i+2);
      if(ROMA_MAP[dig]){ out+=ROMA_MAP[dig]; i++; continue; }
      out += ROMA_MAP[ch] || ch;
    }
    return out;
  }

  // normalizador: macrones precompuestos y combinados → secuencias (ō→ou, ū→uu, etc.)
  const norm = (s)=>{
    if(!s) return '';
    // precompuestos
    const macPre = {'Ā':'aa','ā':'aa','Ī':'ii','ī':'ii','Ū':'uu','ū':'uu','Ē':'ee','ē':'ee','Ō':'ou','ō':'ou'};
    s = s.replace(/[ĀāĪīŪūĒēŌō]/g, ch => macPre[ch] || ch);
    // combinados (vocal + U+0304)
    s = s.replace(/a\u0304/gi,'aa')
         .replace(/i\u0304/gi,'ii')
         .replace(/u\u0304/gi,'uu')
         .replace(/e\u0304/gi,'ee')
         .replace(/o\u0304/gi,'ou');
    // limpia diacríticos restantes y no-alfanum
    return s.toLowerCase()
            .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
            .replace(/[^a-z0-9]/g,'');
  };

  /* ======== Render ======== */
  function renderLine(track, el, mode){
    const show=(state.showJA&&mode==='ja')||(state.showRO&&mode==='ro')||(state.showES&&mode==='es');
    if(!show){ el.hidden=true; el.innerHTML=''; return; }

    let cue=null;
    if(track?.activeCues?.length) cue=track.activeCues[0];
    else if(track?.cues?.length){
      const t=video.currentTime;
      for(let i=0;i<track.cues.length;i++){ const c=track.cues[i]; if(t>=c.startTime && t<=c.endTime){ cue=c; break; } }
    }
    if(!cue){ el.hidden=true; el.innerHTML=''; return; }

    el.hidden=false; el.innerHTML='';
    const lines = cue.text.split(/\r?\n/);
    for(let li=0; li<lines.length; li++){
      const lineText = lines[li];
      if(mode==='ja'){
        const tokens = segmentJapanese(lineText);
        const wrap = document.createElement('span');
        wrap.className='line-ja'; wrap.dataset.text=lineText;
        tokens.forEach((tok,idx)=>{
          const sp=document.createElement('span');
          sp.className='word-ja';
          if(state.showFG && tok.dict){ sp.innerHTML = `<ruby><rb>${tok.text}</rb><rt>${tok.dict.yomi}</rt></ruby>`; }
          else { sp.textContent = tok.text; }
          sp.dataset.word=tok.text.trim();
          sp.dataset.start=tok.start; sp.dataset.end=tok.end; sp.dataset.idx=idx;
          if(tok.dict){
            sp.dataset.dict='1';
            sp.dataset.yomi = tok.dict.yomi || '';
            sp.dataset.gloss= tok.dict.gloss || '';
            if(tok.dict.ro) sp.dataset.roma = tok.dict.ro;
            if(tok.dict.note) sp.dataset.note = tok.dict.note;
          } else sp.dataset.dict='0';
          wrap.appendChild(sp);
        });
        el.appendChild(wrap);
      } else if(mode==='ro'){
        const parts = lineText.split(/(\s+|[.,!?¡¿…:;()\[\]'"-])/).filter(Boolean);
        let idx=0;
        parts.forEach(tok=>{
          if(/\s+|[.,!?¡¿…:;()\[\]'"-]/.test(tok)){
            el.appendChild(document.createTextNode(tok));
          }else{
            const sp=document.createElement('span');
            sp.className='word-ro';
            sp.textContent=tok;
            sp.dataset.norm = norm(tok);
            sp.dataset.idx = String(idx++);
            el.appendChild(sp);
          }
        });
      } else {
        el.appendChild(document.createTextNode(lineText));
      }
      if(li<lines.length-1) el.appendChild(document.createElement('br'));
    }
  }

  function renderCue(){ renderLine(tracks.ja,capJA,'ja'); renderLine(tracks.ro,capRO,'ro'); renderLine(tracks.es,capES,'es'); }
  Object.values(tracks).forEach(t=>{ t && t.addEventListener('cuechange', renderCue); });
  video.addEventListener('timeupdate', renderCue);
  video.addEventListener('seeked', renderCue);
  video.addEventListener('ratechange', renderCue);
  window.addEventListener('load', renderCue);

  /* ======== Popover + highlight RO ======== */
  const pop=$('#popover'), pvWord=$('#pv-word'), pvRead=$('#pv-read'), pvMeaning=$('#pv-meaning');

  function longestDictAt(line, pos){
    let best=null;
    for(const k of DICT_KEYS){
      const i=line.indexOf(k);
      if(i!==-1 && i<=pos && pos<i+k.length){
        if(!best || k.length>best.text.length) best={text:k,start:i,end:i+k.length,entry:JA_DICT[k]};
      }
    }
    return best;
  }

  let roBadgeEl=null;
  function clearROHighlight(){
    capRO.querySelectorAll('.hl').forEach(el=>el.classList.remove('hl'));
    if(roBadgeEl && roBadgeEl.parentNode) roBadgeEl.parentNode.removeChild(roBadgeEl);
    roBadgeEl=null;
  }

  // Busca ventanas contiguas EXACTAS (multi-palabra)
  function highlightInRO(romaji){
    clearROHighlight();
    if(!state.showRO || !romaji) return;
    const target = norm(romaji);
    const toks = Array.from(capRO.querySelectorAll('.word-ro'));
    const norms = toks.map(t=>t.dataset.norm||'');

    for(let i=0;i<norms.length;i++){
      let cat='';
      for(let j=i;j<norms.length;j++){
        cat += norms[j];
        if(cat===target){
          for(let k=i;k<=j;k++) toks[k].classList.add('hl');
          return;
        }
        if(cat.length >= target.length) break;
      }
    }
    for(let i=0;i<norms.length;i++){ if(norms[i]===target){ toks[i].classList.add('hl'); return; } }
    let pick=-1, bestLen=0;
    for(let i=0;i<norms.length;i++){
      const n=norms[i];
      if(n.includes(target) || target.includes(n)){ if(n.length>bestLen){ pick=i; bestLen=n.length; } }
    }
    if(pick!==-1){ toks[pick].classList.add('hl'); return; }
    roBadgeEl=document.createElement('span'); roBadgeEl.className='ro-badge'; roBadgeEl.textContent=romaji; capRO.appendChild(roBadgeEl);
  }

  // Hover en JA → resalta RO
// ==== helpers de highlight ====
function clearJAHighlight(){
  capJA.querySelectorAll('.hl').forEach(el=>el.classList.remove('hl'));
}
function clearROHighlight(){
  capRO.querySelectorAll('.hl').forEach(el=>el.classList.remove('hl'));
  if(roBadgeEl && roBadgeEl.parentNode) roBadgeEl.parentNode.removeChild(roBadgeEl);
  roBadgeEl=null;
}

  /* === HOVER: Japonés -> Romaji (solo si ambos están activos) === */
capJA.addEventListener('mousemove', (e) => {
  // Si no está encendido JA, no hacemos nada
  if (!state.showJA) return;

  const jaSpan = e.target.closest('.word-ja');

  // Limpio highlight previo en JA siempre
  clearJAHighlight();

  // Si salí de una palabra => también limpio RO (si estaba activo) y me voy
  if (!jaSpan) { 
    if (state.showRO) clearROHighlight();
    return; 
  }

  // 1) resalto el token de JA bajo el cursor
  jaSpan.classList.add('hl');

  // 2) sincronizo con RO solo cuando RO también está visible
  if (!state.showRO) return;

  // Calcular romaji: data-roma > data-yomi > texto (si está en ひらがな)
  let romaji = jaSpan.dataset.roma || '';
  let yomi   = jaSpan.dataset.yomi || '';
  const txt  = jaSpan.textContent || '';

  if (!yomi && /[\u3040-\u309F]/.test(txt)) yomi = txt; // si el texto está en hiragana
  if (!romaji && yomi) romaji = hiraToRoma(yomi);

  // Resalto en la línea de RO el/los token(s) que coinciden
  if (romaji) highlightInRO(romaji);
  else clearROHighlight();
});

// Cuando el mouse sale del bloque de JA, limpio ambos
capJA.addEventListener('mouseleave', () => {
  clearJAHighlight();
  if (state.showRO) clearROHighlight();
});

// === HOVER en JAPONÉS → borde violeta + sincroniza con RO ===
document.addEventListener('mousemove',(e)=>{
  if(!state.showJA) return;
  if(!capJA.contains(e.target)){ clearJAHighlight(); return; }

  const jaSpan = e.target.closest('.word-ja');
  if(!jaSpan){ clearJAHighlight(); return; }

  clearJAHighlight();
  jaSpan.classList.add('hl');

  let reading = jaSpan.dataset.yomi || '';
  let romaji  = jaSpan.dataset.roma || '';
  const txt   = jaSpan.textContent || '';
  if(!reading && /[\u3040-\u309f]/.test(txt)) reading = txt;
  if(!romaji && reading) romaji = hiraToRoma(reading);
  if(romaji) highlightInRO(romaji); else clearROHighlight();
});

// === HOVER en RŌMAJI → borde violeta + sincroniza con JA ===
document.addEventListener('mousemove', (e)=>{
  if(!state.showRO) return;

  if(!capRO.contains(e.target)){
    clearROHighlight();
    if(state.showJA) clearJAHighlight();
    return;
  }

  const roSpan = e.target.closest('.word-ro');
  if(!roSpan){
    clearROHighlight();
    if(state.showJA) clearJAHighlight();
    return;
  }

  clearROHighlight();
  roSpan.classList.add('hl');

  const toks = Array.from(capRO.querySelectorAll('.word-ro'));
  const idx  = toks.indexOf(roSpan);
  const get  = i => (i>=0 && i<toks.length)? toks[i].textContent.trim() : null;

  let match=null, entry=null, key=null, win=null;
  outer:
  for (let w=4; w>=1; w--) {
    for (let start=idx-(w-1); start<=idx; start++) {
      if (start<0) continue;
      const parts=[];
      for (let k=0;k<w;k++){ const t=get(start+k); if(!t){ parts.length=0; break; } parts.push(t); }
      if(!parts.length) continue;
      const cand = parts.join(' ');
      for (const k of DICT_KEYS) {
        const e = JA_DICT[k]; if(!e || !e.ro) continue;
        if (norm(e.ro) === norm(cand)) { match=cand; entry=e; key=k; win={start, end:start+w-1}; break outer; }
      }
    }
  }

  if(match){
    for (let i=win.start; i<=win.end; i++) toks[i].classList.add('hl');

    if(state.showJA){
      clearJAHighlight();
      let found=false;
      capJA.querySelectorAll('.word-ja').forEach(sp=>{
        if(sp.dataset.word===key){ sp.classList.add('hl'); found=true; }
      });
      if(!found){
        const wrap=capJA.querySelector('.line-ja');
        const line=wrap?(wrap.dataset.text||''):'';
        const pos=line.indexOf(key);
        if(pos>=0){
          capJA.querySelectorAll('.word-ja').forEach(sp=>{
            const s=Number(sp.dataset.start)||0, en=Number(sp.dataset.end)||0;
            if(s<pos+key.length && en>pos) sp.classList.add('hl');
          });
        }
      }
    }
  }
});

// === LIMPIEZA global si sale del contenedor ===
document.addEventListener('mouseleave', ()=>{
  clearJAHighlight();
  clearROHighlight();
}, true);

document.addEventListener('mousemove',(e)=>{
  if(!state.showJA) return;
  if(!capJA.contains(e.target)){ clearJAHighlight(); return; }

  const jaSpan = e.target.closest('.word-ja');
  if(!jaSpan){ clearJAHighlight(); return; }

  clearJAHighlight();
  jaSpan.classList.add('hl');

  // Buscar entrada como en el click
  const lineWrap = jaSpan.closest('.line-ja');
  const lineText = lineWrap ? lineWrap.dataset.text || '' : '';
  const start = Number(jaSpan.dataset.start) || 0;
  const end = Number(jaSpan.dataset.end) || start + (jaSpan.textContent || '').length;
  const pos = Math.floor((start + end) / 2);

  let surface = jaSpan.dataset.word || jaSpan.textContent;
  let entry = (jaSpan.dataset.dict === '1') ? {
    yomi: jaSpan.dataset.yomi,
    gloss: jaSpan.dataset.gloss,
    ro: jaSpan.dataset.roma,
    note: jaSpan.dataset.note
  } : null;

  if (!entry) {
    const best = longestDictAt(lineText, pos);
    if (best) {
      surface = best.text;
      entry = {
        yomi: best.entry.yomi,
        gloss: best.entry.gloss,
        ro: best.entry.ro,
        note: best.entry.note
      };
    }
  }

  const romaOut = entry?.ro || (entry?.yomi ? hiraToRoma(entry.yomi) : '');
  if (romaOut) highlightInRO(romaOut);
  else clearROHighlight();
});  

// === CLICK EN JAPONÉS → popover + sincroniza RO ===
document.addEventListener('click',(e)=>{
  if(!state.showJA) return;
  if(!capJA.contains(e.target)) { if(!e.target.closest('#popover')) pop.style.display='none'; return; }

  const span=e.target.closest('.word-ja'); if(!span) return;
  const lineWrap=span.closest('.line-ja');
  const lineText=lineWrap?lineWrap.dataset.text||'':'';
  const start=Number(span.dataset.start)||0, end=Number(span.dataset.end)||start+(span.textContent||'').length;
  const pos=Math.floor((start+end)/2);

  let surface = span.dataset.word || span.textContent;
  let entry = (span.dataset.dict==='1') ? {yomi:span.dataset.yomi,gloss:span.dataset.gloss,ro:span.dataset.roma,note:span.dataset.note} : null;

  if(!entry){
    const best=longestDictAt(lineText, pos);
    if(best){ surface=best.text; entry={yomi:best.entry.yomi,gloss:best.entry.gloss,ro:best.entry.ro,note:best.entry.note}; }
  }

  pvWord.textContent = surface;
  pvRead.textContent = 'Lectura: ' + (entry?.yomi || '—');
  pvMeaning.textContent = 'Significado: ' + (entry?.gloss || '—') + (entry?.note ? ' · Uso: ' + entry.note : '');

  const rect=player.getBoundingClientRect();
  pop.style.display='block';
  pop.style.left=(Math.min(rect.width-10, Math.max(10, e.clientX - rect.left + 8)))+'px';
  pop.style.top =(Math.min(rect.height-10, Math.max(10, e.clientY - rect.top + 8)) - 10)+'px';

  const romaOut = entry?.ro || (entry?.yomi ? hiraToRoma(entry.yomi) : '');
  if(romaOut) highlightInRO(romaOut);
}, true);

// === CLICK EN RŌMAJI → popover igual que JA ===
document.addEventListener('click',(e)=>{
  if(!state.showRO) return;
  if(!capRO.contains(e.target)) return;
  const roSpan = e.target.closest('.word-ro'); if(!roSpan) return;

  const toks = Array.from(capRO.querySelectorAll('.word-ro'));
  const idx  = toks.indexOf(roSpan);
  const get  = i => (i>=0 && i<toks.length)? toks[i].textContent.trim() : null;

  const candidates = [];
  for (let w=4; w>=1; w--) {
    for (let start=idx-(w-1); start<=idx; start++) {
      if (start<0) continue;
      const parts=[];
      for (let k=0;k<w;k++){ const t=get(start+k); if(!t){ parts.length=0; break; } parts.push(t); }
      if(parts.length) candidates.push({start, end:start+w-1, text:parts.join(' ')});
    }
  }

  let match=null, entry=null, key=null;
  const keysWithRO = DICT_KEYS.filter(k => JA_DICT[k]?.ro);
  for (const cand of candidates) {
    const cn = norm(cand.text);
    for (const k of keysWithRO) {
      if (norm(JA_DICT[k].ro) === cn) { match=cand; entry=JA_DICT[k]; key=k; break; }
    }
    if(match) break;
  }
  if(!entry) return;

  pvWord.textContent = key;
  pvRead.textContent = 'Lectura: ' + (entry.yomi || '—');
  pvMeaning.textContent = 'Significado: ' + (entry.gloss || '—') + (entry.note ? ' · Uso: ' + entry.note : '');
  const rect=player.getBoundingClientRect();
  pop.style.display='block';
  pop.style.left=(Math.min(rect.width-10, Math.max(10, e.clientX - rect.left + 8)))+'px';
  pop.style.top =(Math.min(rect.height-10, Math.max(10, e.clientY - rect.top + 8)) - 10)+'px';

  clearROHighlight();
  for (let i = match.start; i <= match.end; i++) toks[i].classList.add('hl');

  if (state.showJA) {
    capJA.querySelectorAll('.hl').forEach(el=>el.classList.remove('hl'));
    const spans = Array.from(capJA.querySelectorAll('.word-ja'));
    const wrap = capJA.querySelector('.line-ja');
    const lineText = wrap ? (wrap.dataset.text || '') : '';
    let jStart = lineText.indexOf(key);
    if (jStart >= 0) {
      spans.forEach(sp=>{
        const s = Number(sp.dataset.start)||0, e2 = Number(sp.dataset.end)||0;
        if (s < jStart + key.length && e2 > jStart) sp.classList.add('hl');
      });
    } else {
      const byRo = norm(entry.ro);
      spans.forEach(sp=>{
        const r = sp.dataset.roma || (sp.dataset.yomi ? hiraToRoma(sp.dataset.yomi) : '');
        if (r && norm(r) && byRo.includes(norm(r))) sp.classList.add('hl');
      });
    }
  }
});
// Bloque JS completo y limpio con hover sincronizado JA ⇄ RO, borde violeta y popover sincronizado

 
// === HOVER en JAPONÉS → borde violeta + sincroniza RO ===
document.addEventListener('mousemove', (e) => {
  if (!state.showJA) return;
  if (!capJA.contains(e.target)) { clearJAHighlight(); return; }

  const jaSpan = e.target.closest('.word-ja');
  if (!jaSpan) { clearJAHighlight(); return; }

  clearJAHighlight();
  jaSpan.classList.add('hl');

  const lineWrap = jaSpan.closest('.line-ja');
  const lineText = lineWrap ? lineWrap.dataset.text || '' : '';
  const start = Number(jaSpan.dataset.start) || 0;
  const end = Number(jaSpan.dataset.end) || start + (jaSpan.textContent || '').length;
  const pos = Math.floor((start + end) / 2);

  let surface = jaSpan.dataset.word || jaSpan.textContent;
  let entry = (jaSpan.dataset.dict === '1') ? {
    yomi: jaSpan.dataset.yomi,
    gloss: jaSpan.dataset.gloss,
    ro: jaSpan.dataset.roma,
    note: jaSpan.dataset.note
  } : null;

  if (!entry) {
    const best = longestDictAt(lineText, pos);
    if (best) {
      surface = best.text;
      entry = {
        yomi: best.entry.yomi,
        gloss: best.entry.gloss,
        ro: best.entry.ro,
        note: best.entry.note
      };
    }
  }

  const romaOut = entry?.ro || (entry?.yomi ? hiraToRoma(entry.yomi) : '');
  if (romaOut) highlightInRO(romaOut);
  else clearROHighlight();
});

// === HOVER en RŌMAJI → borde violeta + sincroniza JA ===
document.addEventListener('mousemove', (e) => {
  if (!state.showRO) return;

  if (!capRO.contains(e.target)) {
    clearROHighlight();
    if (state.showJA) clearJAHighlight();
    return;
  }

  const roSpan = e.target.closest('.word-ro');
  if (!roSpan) {
    clearROHighlight();
    if (state.showJA) clearJAHighlight();
    return;
  }

  clearROHighlight();
  roSpan.classList.add('hl');

  const toks = Array.from(capRO.querySelectorAll('.word-ro'));
  const idx = toks.indexOf(roSpan);
  const get = i => (i >= 0 && i < toks.length) ? toks[i].textContent.trim() : null;

  const candidates = [];
  for (let w = 4; w >= 1; w--) {
    for (let start = idx - (w - 1); start <= idx; start++) {
      if (start < 0) continue;
      const parts = [];
      for (let k = 0; k < w; k++) {
        const t = get(start + k);
        if (!t) { parts.length = 0; break; }
        parts.push(t);
      }
      if (parts.length) candidates.push({ start, end: start + w - 1, text: parts.join(' ') });
    }
  }

  let match = null, entry = null, key = null;
  const keysWithRO = DICT_KEYS.filter(k => JA_DICT[k]?.ro);
  for (const cand of candidates) {
    const cn = norm(cand.text);
    for (const k of keysWithRO) {
      if (norm(JA_DICT[k].ro) === cn) {
        match = cand;
        entry = JA_DICT[k];
        key = k;
        break;
      }
    }
    if (match) break;
  }

  if (!entry) return;

  for (let i = match.start; i <= match.end; i++) toks[i].classList.add('hl');

  if (state.showJA) {
    clearJAHighlight();
    const spans = Array.from(capJA.querySelectorAll('.word-ja'));
    const wrap = capJA.querySelector('.line-ja');
    const lineText = wrap ? (wrap.dataset.text || '') : '';
    let jStart = lineText.indexOf(key);

    if (jStart >= 0) {
      spans.forEach(sp => {
        const s = Number(sp.dataset.start) || 0;
        const e2 = Number(sp.dataset.end) || 0;
        if (s < jStart + key.length && e2 > jStart) sp.classList.add('hl');
      });
    } else {
      const byRo = norm(entry.ro);
      spans.forEach(sp => {
        const r = sp.dataset.roma || (sp.dataset.yomi ? hiraToRoma(sp.dataset.yomi) : '');
        if (r && norm(r) && byRo.includes(norm(r))) sp.classList.add('hl');
      });
    }
  }
});

// === CLICK EN JAPONÉS → popover + sincroniza RO ===
document.addEventListener('click', (e) => {
  if (!state.showJA) return;
  if (!capJA.contains(e.target)) { if (!e.target.closest('#popover')) pop.style.display = 'none'; return; }

  const span = e.target.closest('.word-ja'); if (!span) return;
  const lineWrap = span.closest('.line-ja');
  const lineText = lineWrap ? lineWrap.dataset.text || '' : '';
  const start = Number(span.dataset.start) || 0, end = Number(span.dataset.end) || start + (span.textContent || '').length;
  const pos = Math.floor((start + end) / 2);

  let surface = span.dataset.word || span.textContent;
  let entry = (span.dataset.dict === '1') ? {
    yomi: span.dataset.yomi,
    gloss: span.dataset.gloss,
    ro: span.dataset.roma,
    note: span.dataset.note
  } : null;

  if (!entry) {
    const best = longestDictAt(lineText, pos);
    if (best) {
      surface = best.text;
      entry = {
        yomi: best.entry.yomi,
        gloss: best.entry.gloss,
        ro: best.entry.ro,
        note: best.entry.note
      };
    }
  }

  pvWord.textContent = surface;
  pvRead.textContent = 'Lectura: ' + (entry?.yomi || '—');
  pvMeaning.textContent = 'Significado: ' + (entry?.gloss || '—') + (entry?.note ? ' · Uso: ' + entry.note : '');

  const rect = player.getBoundingClientRect();
  pop.style.display = 'block';
  pop.style.left = (Math.min(rect.width - 10, Math.max(10, e.clientX - rect.left + 8))) + 'px';
  pop.style.top = (Math.min(rect.height - 10, Math.max(10, e.clientY - rect.top + 8)) - 10) + 'px';

  const romaOut = entry?.ro || (entry?.yomi ? hiraToRoma(entry.yomi) : '');
  if (romaOut) highlightInRO(romaOut);
});

// === CLICK EN RŌMAJI → popover igual que JA ===
document.addEventListener('click',(e)=>{
  if(!state.showRO) return;
  if(!capRO.contains(e.target)) return;
  const roSpan = e.target.closest('.word-ro'); if(!roSpan) return;

  const toks = Array.from(capRO.querySelectorAll('.word-ro'));
  const idx  = toks.indexOf(roSpan);
  const get  = i => (i>=0 && i<toks.length)? toks[i].textContent.trim() : null;

  const candidates = [];
  for (let w=4; w>=1; w--) {
    for (let start=idx-(w-1); start<=idx; start++) {
      if (start<0) continue;
      const parts=[];
      for (let k=0;k<w;k++){ const t=get(start+k); if(!t){ parts.length=0; break; } parts.push(t); }
      if(parts.length) candidates.push({start, end:start+w-1, text:parts.join(' ')});
    }
  }

  let match=null, entry=null, key=null;
  const keysWithRO = DICT_KEYS.filter(k => JA_DICT[k]?.ro);
  for (const cand of candidates) {
    const cn = norm(cand.text);
    for (const k of keysWithRO) {
      if (norm(JA_DICT[k].ro) === cn) { match=cand; entry=JA_DICT[k]; key=k; break; }
    }
    if(match) break;
  }
  if(!entry) return;

  pvWord.textContent = key;
  pvRead.textContent = 'Lectura: ' + (entry.yomi || '—');
  pvMeaning.textContent = 'Significado: ' + (entry.gloss || '—') + (entry.note ? ' · Uso: ' + entry.note : '');
  const rect=player.getBoundingClientRect();
  pop.style.display='block';
  pop.style.left=(Math.min(rect.width-10, Math.max(10, e.clientX - rect.left + 8)))+'px';
  pop.style.top =(Math.min(rect.height-10, Math.max(10, e.clientY - rect.top + 8)) - 10)+'px';

  clearROHighlight();
  for (let i = match.start; i <= match.end; i++) toks[i].classList.add('hl');

  if (state.showJA) {
    capJA.querySelectorAll('.hl').forEach(el=>el.classList.remove('hl'));
    const spans = Array.from(capJA.querySelectorAll('.word-ja'));
    const wrap = capJA.querySelector('.line-ja');
    const lineText = wrap ? (wrap.dataset.text || '') : '';
    let jStart = lineText.indexOf(key);
    if (jStart >= 0) {
      spans.forEach(sp=>{
        const s = Number(sp.dataset.start)||0, e2 = Number(sp.dataset.end)||0;
        if (s < jStart + key.length && e2 > jStart) sp.classList.add('hl');
      });
    } else {
      const byRo = norm(entry.ro);
      spans.forEach(sp=>{
        const r = sp.dataset.roma || (sp.dataset.yomi ? hiraToRoma(sp.dataset.yomi) : '');
        if (r && norm(r) && byRo.includes(norm(r))) sp.classList.add('hl');
      });
    }
  }
});

// === LIMPIEZA al salir del documento ===
document.addEventListener('mouseleave', () => {
  clearJAHighlight();
  clearROHighlight();
}, true);

  
  // Herramientas y atajos
  $('#btnTest').addEventListener('click', ()=>{ setSrc('https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'); log('Cargando video de prueba MDN'); });
  $('#btnURL').addEventListener('click', ()=>{ const u=prompt('Pegá una URL directa a .mp4 (https://...)'); if(!u) return; setSrc(u.trim()); log('Cambié src a '+u); });
  document.addEventListener('keydown',(e)=>{ if(e.key==='j' || e.key==='J'){ togJA.click(); } if(e.key==='a' || e.key==='A'){ togRO.click(); } if(e.key==='e' || e.key==='E'){ togES.click(); } if(e.key==='g' || e.key==='G'){ togFG.click(); } });

  // Herramientas y atajos
  $('#btnTest').addEventListener('click', ()=>{ setSrc('https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'); log('Cargando video de prueba MDN'); });
  $('#btnURL').addEventListener('click', ()=>{ const u=prompt('Pegá una URL directa a .mp4 (https://...)'); if(!u) return; setSrc(u.trim()); log('Cambié src a '+u); });
  document.addEventListener('keydown',(e)=>{ if(e.key==='j' || e.key==='J'){ togJA.click(); } if(e.key==='a' || e.key==='A'){ togRO.click(); } if(e.key==='e' || e.key==='E'){ togES.click(); } if(e.key==='g' || e.key==='G'){ togFG.click(); } });
})();
</script>
</body>
</html>





















